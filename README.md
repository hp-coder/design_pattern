# java design pattern
`GoF : gang of four`

## Abstract Document

`extensibility, structral`

- 应用
    - 动态属性
    - 树一样的灵活的领域对象结构
    - 低耦合系统
- 特点
    - 属性通过接口定义，但是保存在无状态map中，通过实现对应属性接口的获取数据方法，从对象的属性map中获取对应的属性值
    - 当存在复杂属性时，及某个属性又是由多个属性构成时，也要实现抽象父类和其他单一属性的接口, 复杂属性在保存在实体对象中时，又是由多个单一属性组成，对于实体来说也就是这个复杂属性化简为多个单一属性，也即形成了一个List结构
- 编码
    - 当构造函数只有一个参数时，实际就是一个Function函数（Funtion<Parameter, ObjInstance> constructor）

## Abstract Factory

`gang of four, creational`

- 关联
    - Factory Method
    - Factory Kit
- 特点
    - 面向接口编程
    - 工厂的工厂，继承新产品方便
    - 避免了if-else，switch的麻烦（但还是要决定实例化哪个具体的工厂）
- 编码
    - 定义工厂接口，接口中定义获取实例方法，对应实例工厂实现抽象工厂，实现获取实例方法返回实例的统一父类或接口，使用时根据需要传入对应实例工厂，调用创建实例方法，进而获取对应实例
- 应用
    - 独立的构建产品
    - 需要构建多个族中的某一族产品，而且这几个产品必须在一族中使用，这种模式增强了产品之间的关系 （同时也导致了一族中产品扩展十分困难）
    - 提供一个以接口访问的产品库
    - 动态的获取实例
- 缺点
    - 依赖注入隐藏了本可以在编译期间可发现的异常，导致可能在运行期间出现
    - 同族加产品十分困难，因为都是通过获取产品的接口定义在顶层的工厂接口里的
    - 导致代码变得复杂

## Active Object

`performence, concurrency`
- 特点
  - 将方法的异步执行放到实例内部实现，调用者只需要关心如何调用即可
  - 每个实例将维护自己的一个线程和一个任务队列，实例化时，将创建一个线程不断的尝试消费队列中的任务
  - 线程数量不可控
- 编码
  - 定义主动对象接口，实例话要创建实例使用的线程，并不断消费队列中任务，每个方法的实现要将方法作为任务提交到队列中执行
  - 如果是需要返回值的任务，则可以通过构建一个Future类来获取结果，该Future对象要作为参数传入方法中，当方法未完成时，Futurn中调用获取返回值方法将一直wait，直到主动对象的方法执行完成将结果设置到future中，Future将notify通知主线程，也即完成了异步调用返回结果
  - 可以将任务队列简单的从一个blockingQueue编写为一个生产消费者管理的队列来减少轮训次数
  - 可以使用代理模式将主动对象封装，返回代理对象，由代理对象返回future对象

## Acyclic Visitor

`extensibility, behavioral`

- 编码
  - accept(访问扩展接口顶层父类)：判断扩展接口具体的实例类型，并调用visit，传入功能类对象
  - visit(功能类)：此时已经是用扩展类中获取到功能类对象，处理功能类需要的业务
- 特点
  - 面向接口编程，在不扩展功能类的方法等情况下
  - 根据扩展接口的实例不同执行不同的操作
  - 相较于Visitor模式，消除循环依赖，因为Visitor模式中，扩展方法都是定义在Visitor的顶层父类中，如果要完全隔离default实现的情况下，在父类中增加方法，子类必然需要实现，Acyclic Visitor的顶层父类中不定义方法，由子类定义，在被访问的主要功能类中通过cast指定具体是子类是什么Visitor时调用，这样当功能类扩展时，访问类就避免类在 顶层父类中增加，导致子类都要实现的情况

## Adapter

also known as `wrapper`

`gang of four, structural`

- 目的
  - 将一个接口的实例转化为另一个接口的实例，使得不兼容的接口能使用
- plain words解释
  - 一只老虎等运动接口是跑，但一只飞虎这需要飞，那么飞虎adapter接收老虎作为构造条件，将运动接口用飞实现，调用飞虎对象时则传入的是飞虎adapter（老虎）这个对象

- 编码
  - adapter类一般情况都要实现被适配类的功能接口或者继承其父类，形成同一个类型
  - adapter中使用构造强制接收一个被适配类的实例，使用同样的功能方法将被适配类的数据处理 
  - 使用上一般是需要传入adapter类作为实际入餐，而不是像菜鸟教程中将被适配类作为参数
- 特点 
  - 使用一个已存在的类，但接口不是对应的
  - 多个子类，每个都单独做adapter不现实，那么可以实现适配父类的一个通用适配器
  - 解耦与外部类库的依赖，更新类库只需要增加adapter即可
- 结果
  - 类适配器
    - 直接继承于被适配类，所以无法适配另一个类和它的子类
    - 其实是让适配器重写了被适配对象的方法，适配器就是一个被适配类的子类，直接继承于被适配类
    - 适配器能直接的找到被适配对象，而不是通过不直接的指针
  - 对象适配器
    - 通过实现于被适配类相同的接口，面向接口
    - 一个适配器适配所有被适配对象，所有子类，可以添加一个对所有被适配类的新功能
    - 重写被适配方法更难，需要被适配对象的子类，使得引用是子类而非被适配类本身

## Aggregator MicroServices

`cloud distributed, decoupling, microservices, architectural`

- 编码
  - 聚合服务调用多个微服务的结果整合到一个地方组装数据返回

## Ambassador

`cloud distributed, decoupling, structural`

- 特点
  - 仅针对历史的微服务的办法，远程微服务无法修改，或极难修改的情况下，新的功能，例如日志，延迟检测等，可以通过继承同样的接口然后对该远程service包装以达到目的
  - 为远程服务提供了一个本地接口
  - 为远程服务提供日志，熔断，重试，安全检查等 