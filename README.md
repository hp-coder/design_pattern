# java design pattern
`GoF : gang of four`

## Abstract Document

`extensibility, structral`

- 应用
    - 动态属性
    - 树一样的灵活的领域对象结构
    - 低耦合系统
- 特点
    - 属性通过接口定义，但是保存在无状态map中，通过实现对应属性接口的获取数据方法，从对象的属性map中获取对应的属性值
    - 当存在复杂属性时，及某个属性又是由多个属性构成时，也要实现抽象父类和其他单一属性的接口, 复杂属性在保存在实体对象中时，又是由多个单一属性组成，对于实体来说也就是这个复杂属性化简为多个单一属性，也即形成了一个List结构
- 编码
    - 当构造函数只有一个参数时，实际就是一个Function函数（Funtion<Parameter, ObjInstance> constructor）

## Abstract Factory

`gang of four, creational`

- 关联
    - Factory Method
    - Factory Kit
- 特点
    - 面向接口编程
    - 工厂的工厂，继承新产品方便
    - 避免了if-else，switch的麻烦（但还是要决定实例化哪个具体的工厂）
- 编码
    - 定义工厂接口，接口中定义获取实例方法，对应实例工厂实现抽象工厂，实现获取实例方法返回实例的统一父类或接口，使用时根据需要传入对应实例工厂，调用创建实例方法，进而获取对应实例
- 应用
    - 独立的构建产品
    - 需要构建多个族中的某一族产品，而且这几个产品必须在一族中使用，这种模式增强了产品之间的关系 （同时也导致了一族中产品扩展十分困难）
    - 提供一个以接口访问的产品库
    - 动态的获取实例
- 缺点
    - 依赖注入隐藏了本可以在编译期间可发现的异常，导致可能在运行期间出现
    - 同族加产品十分困难，因为都是通过获取产品的接口定义在顶层的工厂接口里的
    - 导致代码变得复杂

## Active Object

`performence, concurrency`
- 特点
  - 将方法的异步执行放到实例内部实现，调用者只需要关心如何调用即可
  - 每个实例将维护自己的一个线程和一个任务队列，实例化时，将创建一个线程不断的尝试消费队列中的任务
  - 线程数量不可控
- 编码
  - 定义主动对象接口，实例话要创建实例使用的线程，并不断消费队列中任务，每个方法的实现要将方法作为任务提交到队列中执行
  - 如果是需要返回值的任务，则可以通过构建一个Future类来获取结果，该Future对象要作为参数传入方法中，当方法未完成时，Futurn中调用获取返回值方法将一直wait，直到主动对象的方法执行完成将结果设置到future中，Future将notify通知主线程，也即完成了异步调用返回结果
  - 可以将任务队列简单的从一个blockingQueue编写为一个生产消费者管理的队列来减少轮训次数
  - 可以使用代理模式将主动对象封装，返回代理对象，由代理对象返回future对象

## Acyclic Visitor

`extensibility, behavioral`

- 编码
  - accept(访问扩展接口顶层父类)：判断扩展接口具体的实例类型，并调用visit，传入功能类对象
  - visit(功能类)：此时已经是用扩展类中获取到功能类对象，处理功能类需要的业务
- 特点
  - 面向接口编程，在不扩展功能类的方法等情况下
  - 根据扩展接口的实例不同执行不同的操作
  - 相较于Visitor模式，消除循环依赖，因为Visitor模式中，扩展方法都是定义在Visitor的顶层父类中，如果要完全隔离default实现的情况下，在父类中增加方法，子类必然需要实现，Acyclic Visitor的顶层父类中不定义方法，由子类定义，在被访问的主要功能类中通过cast指定具体是子类是什么Visitor时调用，这样当功能类扩展时，访问类就避免类在 顶层父类中增加，导致子类都要实现的情况